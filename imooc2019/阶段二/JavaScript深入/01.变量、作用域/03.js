//引用类型传递也是按值传递
function  setName(obj){
    obj.name='xm';
    obj={}//obj指向其他对象 此时修改obj的内存地址，与person无关
    obj.name='xh'
}
var person={}
setName(person)
console.log(person.name);


// instanceof 判断是不是构造函数的实例(只能用在引用类型上)
console.log([] instanceof Array);
console.log([] instanceof Object);
console.log({} instanceof Object);



function log(a){
    a=1
}
var b=2
log(b)
console.log(b);

// 1  js 中的数据类型分为两类

// 原始数据类型【primitive type】： undefined   null boolean number  string

// 引用类型[Object type]:   Object,Array,Function,Date

// 2 声明变量时不同的内存分配

// 原始值： 存储在stack中简单的数据段， 他们的值直接存储在变量访问的位置

// 原因： 原始类型占据的空间是固定的，所以可以将他们存储在较小的内存区域-栈中，便于迅速查询变量的值

// 引用值： 存储在heap中的对象，存储在变量处的值是一个指针（point）,指向存储对象的内存地址

// 原因： 引用值的大小会改变，所以不能放在栈中，否则会降低变量查询速度，放在变量的栈空间中的值是

// 对象存储在堆中的地址，地址的大小是固定的，所以把它存储在栈中对变量性能无任何负面影响

// 3 js中对象的访问

// 在js中是不允许直接访问保存在堆内存中的对象， 所以访问一个对象时， 首先得到的是这个对象在堆内存中的地址

// ，然后按照这个地址去获得这个对象的值，这就是按引用访问，

// 原始类型的值可以直接访问到

// 4 复制变量时的不同

// 原始值： 将一个保存着原始值的变量复制给另一个变量，会将原始值的副本赋给新变量，此后两个变量是完全独立

// 只是拥有相同的value而已

// 引用值： 一个保存着对象内存地址的变量复制给另一个变量，会把这个内存地址赋值给新变量，也就是说这两个变量都指向

// 堆内存中的同一个对象，他们中任何一个发生改变都会反映在另一个身上【并不会在堆内存中新生成一个一模一样的对象，只是多了一个保存指向这个对象指针的变量】

// 5  参数传递的不同

// a:   js中所有函数的参数都是按值来传递的 【传递参数的时候，就是把实参复制给形参的过程】

// b:  原始值： 只是把变量里的值传递给参数，之后参数和这个变量互不影响

// c:  引用值： 对象里面的值是这个对象在堆内存中的内存地址，参数和对象将会指向同一个对象
